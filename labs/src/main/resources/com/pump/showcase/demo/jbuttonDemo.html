<!DOCTYPE html>
<html>
<head>
<title>JButton, QButtonUI Demo</title>
</head>
<body>
<h1>JButton, QButtonUI Demo</h1>
<h2>What Is It</h2>
<p>This demo features JButton configuration options and new QButtonUI implementations.</p>
<h2>How To Use It</h2>
<p>Use the "Configuration" panel to control the buttons in the "Example" panel.</p>
<p>The 5 <code>QButtonUIs</code> can be installed by calling:</p>
<pre>button.setUI(new BevelButtonUI());
button.setUI(new GradientButtonUI());
button.setUI(new RecessedButtonUI());
button.setUI(new RoundRectButtonUI());
button.setUI(new SquareButtonUI());</pre>
<p>All configuration controls have specific tooltips that describe what property they define.</p>
<h2>How It Works</h2>
<h3>AquaButtonUI</h3>
<p>If you're viewing this on Mac: the default ButtonUI is the AquaButtonUI. This demo shows off 3 special features of the AquaButtonUI:</p>
<ul><li><em>Button Type</em>: Apple offers a few specific button types to choose from. There <a href="http://developer.apple.com/technotes/tn2007/tn2196.html#BUTTONS">used to be</a> more, and they used to have specific roles/usages. But now Apple has simpler guidelines, and for the most part they encourage you to just the default <a href="https://developer.apple.com/design/human-interface-guidelines/macos/buttons/push-buttons/">push button</a>.</li>
    <li><em>Segment Position</em>: If a button type supports segmented positions: then the demo includes three consecutive buttons "Left", "Middle", "Right". Segmented buttons are still often used in toolbars in Mac applications.</li>
    <li><em>Size Variant</em>: these help shrink buttons ("regular", "small", "mini"). I don't have any examples handy that demonstrate whether Apple still encourages using this practice, though.</li></ul>
<h3>QButtonUI</h3>
<p>This demo also includes five new UIs: BevelButtonUI, GradientButtonUI, RecessedButtonUI, RoundRectButtonUI, SquareButtonUI. These are all subclasses of the abstract QButtonUI class. QButtonUI subclasses include the following options:</p>
<ul><li><em>Segment Positions</em>: these are similar to Apple's implementation. QButtonUIs also include vertical segment positions, although this is not included in the demo. (Because, really, who needs vertically segmented buttons?)</li>
    <li><em>Paint Stroke</em>: these buttons are mostly rendered using a call to <code>Graphics2D.fill(shape)</code> and a separate call to <code>Graphics2D.draw(shape)</code>. This client property toggles off the <code>Graphics2D.draw(..)</code> instruction. (The <code>AbstractButton.isContentAreaFilled()</code> method is used to toggle the <code>Graphics2D.fill(..)</code> instruction.)</li>
    <li><em>Paint Focus</em>: focus can be painted outside the button shape or inside the button shape. (And <code>AbstractButton.setFocusPainted(..)</code> toggles the presence of a painted focus entirely.)</li>
    <li>Buttons can also be rendered as a circle. This option is intended to only be used for buttons with an icon and no text. For example: a help button or a play/pause button.</li>
    <li>QButtonUIs can be converted to QComboBoxUIs so your JComboBoxes can match your JButtons in appearance. QComboBoxes include Apple's concept of being a "Pop-Up" button vs being a "Pull-Down" button.</li>
</ul>
<p>There is no "size variant" option, but you can manually change the corner radius size and font size of buttons tweak the size.</p>
<p>QButtonUIs are vector-based, so if you render them on high-resolution monitors or otherwise change their size they should scale well.</p>
</body></html>